#include <irrlicht.h>
#include "Combate.h"

Combate::Combate(IrrlichtDevice *device,IVideoDriver *driver,ISceneManager *smgr){
//Inicializamos un escenario
	escenario = new Escenario(smgr,driver);
//Inicializamos un cerdo rosa :3
	cerdo = new Personaje();
	if (cerdo->loadMesh(smgr,(char *)"media/cerdo.x")!=0)
	{
		device->drop();
	}
	if (cerdo->addNode(smgr,driver,(char *)"media/cerdo.png")!=0)
	{
		device->drop();
	}
//Le añadimos colisión con el escenario
	cerdo->addCollision(smgr,escenario->getSelector());

//Inicializamos un cerdo azul :3
    otrocerdo = new Personaje();
	if (otrocerdo->loadMesh(smgr,(char *)"media/cerdo.x")!=0)
	{
		device->drop();
	}
	if (otrocerdo->addNode(smgr,driver,(char *)"media/cerdoAzul.png")!=0)
	{
		device->drop();
	}
	otrocerdo->addCollision(smgr,escenario->getSelector());

//Ponemos una bomba
    bomba = new Bomba();
	if (bomba->loadMesh(smgr,(char *)"media/bomba.obj")!=0)
	{
		device->drop();
	}
	if (bomba->addNode(smgr,driver,(char *)"media/bomba.png")!=0)
	{
		device->drop();
	}
	bomba->addCollision(smgr,escenario->getSelector());

//Inicializamos receptor de eventos y cámara
	smgr->setShadowColor(video::SColor(150,0,0,0));
	receiver = new EventReceiver();
	device->setEventReceiver(receiver);
	camara = new Camara(smgr);

//Posicionamos las cosas en una posición inicial
	cerdo->getNode()->setPosition(vector3df(-100.0f,60.0f,0.0f));
	bomba->getNode()->setPosition(vector3df(0.0f,60.0f,0.0f));
	otrocerdo->getNode()->setPosition(vector3df(100.0f,60.0f,40.0f));
	otrocerdo->getNode()->setRotation(vector3df(0.0f,-180.0f,0.0f));
}

Combate::~Combate(){
delete camara;
delete receiver;
delete bomba;
delete otrocerdo;
delete cerdo;
delete escenario;
}

//Actualización del combate
void Combate::actualizar(IrrlichtDevice *device,ISceneManager *smgr,IVideoDriver *driver){

//Según las teclas WSAD, aceleramos o giramos al cerdo
		if(receiver->IsKeyDown(KEY_KEY_W))
			cerdo->acelera(true);
		else if(receiver->IsKeyDown(KEY_KEY_S))
			cerdo->acelera(false);
		if(receiver->IsKeyDown(KEY_KEY_A))
			cerdo->gira(true);
		else if(receiver->IsKeyDown(KEY_KEY_D))
			cerdo->gira(false);

//Actualizamos al otro cerdo
		cerdo->actualizar();
}

int Combate::GetRandInt(int TMax){ 
	return rand() % TMax;
}
 // Runs the physics simulation.
// - TDeltaTime tells the simulation how much time has passed since the last frame so the simulation can run independently of the frame rate.
void Combate::UpdatePhysics(u32 TDeltaTime) {

	World->stepSimulation(TDeltaTime * 0.001f, 60);

	// Relay the object's orientation to irrlicht
	for(list<btRigidBody *>::Iterator Iterator = Objects.begin(); Iterator != Objects.end(); ++Iterator) {

		UpdateRender(*Iterator);
	}	
}

// Creates a base box
void Combate::CreateStartScene(IVideoDriver *driver,ISceneManager *smgr) {

	ClearObjects();
	CreateBox(btVector3(0.0f, 0.0f, 0.0f), vector3df(10.0f, 0.5f, 10.0f), 0.0f,driver,smgr);
}

// Create a box rigid body
void Combate::CreateBox(const btVector3 &TPosition, const vector3df &TScale, btScalar TMass,IVideoDriver *driver,ISceneManager *smgr) {

	ISceneNode *Node = smgr->addCubeSceneNode(1.0f);
	Node->setScale(TScale);
	Node->setMaterialFlag(EMF_LIGHTING, 1);
	Node->setMaterialFlag(EMF_NORMALIZE_NORMALS, true);
	Node->setMaterialTexture(0, driver->getTexture("media/rust0.jpg"));

	// Set the initial position of the object
	btTransform Transform;
	Transform.setIdentity();
	Transform.setOrigin(TPosition);

	btDefaultMotionState *MotionState = new btDefaultMotionState(Transform);

	// Create the shape
	btVector3 HalfExtents(TScale.X * 0.5f, TScale.Y * 0.5f, TScale.Z * 0.5f);
	btCollisionShape *Shape = new btBoxShape(HalfExtents);

	// Add mass
	btVector3 LocalInertia;
	Shape->calculateLocalInertia(TMass, LocalInertia);

	// Create the rigid body object
	btRigidBody *RigidBody = new btRigidBody(TMass, MotionState, Shape, LocalInertia);

	// Store a pointer to the irrlicht node so we can update it later
	RigidBody->setUserPointer((void *)(Node));

	// Add it to the world
	World->addRigidBody(RigidBody);
	Objects.push_back(RigidBody);
}

// Create a sphere rigid body
void Combate::CreateSphere(const btVector3 &TPosition, btScalar TRadius, btScalar TMass,IVideoDriver *driver,ISceneManager *smgr) {

	ISceneNode *Node = smgr->addSphereSceneNode(TRadius, 32);
	Node->setMaterialFlag(EMF_LIGHTING, 1);
	Node->setMaterialFlag(EMF_NORMALIZE_NORMALS, true);
	Node->setMaterialTexture(0, driver->getTexture("media/ice0.jpg"));

	// Set the initial position of the object
	btTransform Transform;
	Transform.setIdentity();
	Transform.setOrigin(TPosition);

	btDefaultMotionState *MotionState = new btDefaultMotionState(Transform);

	// Create the shape
	btCollisionShape *Shape = new btSphereShape(TRadius);

	// Add mass
	btVector3 LocalInertia;
	Shape->calculateLocalInertia(TMass, LocalInertia);

	// Create the rigid body object
	btRigidBody *RigidBody = new btRigidBody(TMass, MotionState, Shape, LocalInertia);

	// Store a pointer to the irrlicht node so we can update it later
	RigidBody->setUserPointer((void *)(Node));

	// Add it to the world
	World->addRigidBody(RigidBody);
	Objects.push_back(RigidBody);
}

// Passes bullet's orientation to irrlicht
void Combate::UpdateRender(btRigidBody *TObject) {
	ISceneNode *Node = static_cast<ISceneNode *>(TObject->getUserPointer());

	// Set position
	btVector3 Point = TObject->getCenterOfMassPosition();
	Node->setPosition(vector3df((f32)Point[0], (f32)Point[1], (f32)Point[2]));

	// Set rotation
	vector3df Euler;
	const btQuaternion& TQuat = TObject->getOrientation();
	quaternion q(TQuat.getX(), TQuat.getY(), TQuat.getZ(), TQuat.getW());
	q.toEuler(Euler);
	Euler *= RADTODEG;
	Node->setRotation(Euler);
}

// Removes all objects from the world
void Combate::ClearObjects() {

	for(list<btRigidBody *>::Iterator Iterator = Objects.begin(); Iterator != Objects.end(); ++Iterator) {
		btRigidBody *Object = *Iterator;

		// Delete irrlicht node
		ISceneNode *Node = static_cast<ISceneNode *>(Object->getUserPointer());
		Node->remove();

		// Remove the object from the world
		World->removeRigidBody(Object);

		// Free memory
		delete Object->getMotionState();
		delete Object->getCollisionShape();
		delete Object;
	}

	Objects.clear();
}
